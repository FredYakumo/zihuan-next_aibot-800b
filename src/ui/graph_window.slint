import { HorizontalBox, VerticalBox, ScrollView, LineEdit, CheckBox, Palette } from "std-widgets.slint";
import { AppTheme } from "theme.slint";

export struct PortVm {
    name: string,
    is_input: bool,
    is_connected: bool,
    is_required: bool,
    data_type: string,
    inline_text: string,
    inline_bool: bool,
}

export struct NodeVm {
    id: string,
    label: string,
    preview_text: string,
    node_type: string,
    string_data_text: string,
    x: float,
    y: float,
    width: float,
    height: float,
    input_ports: [PortVm],
    output_ports: [PortVm],
    is_selected: bool,
}

export struct EdgeVm {
    from_node_id: string,
    from_port: string,
    to_node_id: string,
    to_port: string,
    from_x: float,
    from_y: float,
    to_x: float,
    to_y: float,
    is_selected: bool,
}

export struct EdgeSegmentVm {
    x: float,
    y: float,
    width: float,
    height: float,
    edge_index: int,
}

export struct EdgeCornerVm {
    x: float,
    y: float,
    edge_index: int,
}

export struct EdgeLabelVm {
    text: string,
    x: float,
    y: float,
    width: float,
    height: float,
}

export struct GridLineVm {
    x1: float,
    y1: float,
    x2: float,
    y2: float,
}

export struct NodeTypeVm {
    type_id: string,
    display_name: string,
    category: string,
    description: string,
}

component CjkText inherits Text {
    font-family: "Heiti SC";
    color: AppTheme.text-primary;
}

component CjkButton inherits Rectangle {
    in property <string> text;
    callback clicked();

    width: 120px;
    height: 32px;
    background: AppTheme.surface-overlay;
    border-radius: 6px;
    border-width: 1px;
    border-color: AppTheme.border;

    TouchArea {
        clicked => { root.clicked(); }
    }

    CjkText {
        text: root.text;
        color: AppTheme.text-primary;
        vertical-alignment: center;
        horizontal-alignment: center;
        font-size: 12px;
    }
}

component CjkDeleteButton inherits Rectangle {
    in property <string> text;
    callback clicked();

    width: 120px;
    height: 32px;
    background: AppTheme.danger-bg;
    border-radius: 6px;
    border-width: 1px;
    border-color: AppTheme.danger;

    TouchArea {
        clicked => { root.clicked(); }
    }

    CjkText {
        text: root.text;
        color: AppTheme.text-on-primary;
        vertical-alignment: center;
        horizontal-alignment: center;
        font-size: 12px;
        font-weight: 700;
    }
}

component CjkRunButton inherits Rectangle {
    in property <string> text;
    callback clicked();

    width: 120px;
    height: 32px;
    background: AppTheme.primary-muted;
    border-radius: 6px;
    border-width: 1px;
    border-color: AppTheme.primary;

    TouchArea {
        clicked => { root.clicked(); }
    }

    CjkText {
        text: root.text;
        color: AppTheme.text-on-primary;
        vertical-alignment: center;
        horizontal-alignment: center;
        font-size: 12px;
        font-weight: 700;
    }
}

component NodeItem inherits Rectangle {
    in property <string> node_id;
    in property <string> label;
    in property <string> preview_text;
    in property <string> node_type;
    in property <string> string_data_text;
    in property <float> x_pos;
    in property <float> y_pos;
    in-out property <float> node_width;
    in-out property <float> node_height;
    in property <[PortVm]> input_ports;
    in property <[PortVm]> output_ports;
    in property <float> grid_size;
    in property <float> node_width_cells;
    in property <float> header_rows;
    in property <float> min_rows;
    in property <bool> is_selected;
    
    callback node_moved(float, float);
    callback node_move_finished(float, float);
    callback port_clicked(string, string, bool);
    callback node_clicked(string);
    callback inline_port_text_changed(string, string, string);
    callback inline_port_bool_changed(string, string, bool);
    callback node_resized(float, float);
    callback node_resize_finished(float, float);

    property <float> offset-x: 0;
    property <float> offset-y: 0;
    property <float> drag-start-pointer-x: 0;
    property <float> drag-start-pointer-y: 0;
    property <float> drag-start-node-x: 0;
    property <float> drag-start-node-y: 0;
    property <bool> is-dragging: false;
    property <bool> is-resizing: false;
    property <float> resize-start-pointer-x: 0;
    property <float> resize-start-pointer-y: 0;
    property <float> resize-start-width: 0;
    property <float> resize-start-height: 0;
    property <float> inner-padding-bottom: grid_size * 0.8;

    x: (x_pos + offset-x) * 1px;
    y: (y_pos + offset-y) * 1px;
    width: max(node_width, grid_size * node_width_cells) * 1px;
    height: max(
        node_height,
        grid_size * max(min_rows, header_rows + max(input_ports.length, output_ports.length)) + inner-padding-bottom
    ) * 1px;
    background: touch.pressed ? AppTheme.node-bg-pressed : AppTheme.node-bg;
    border-radius: 8px;
    border-width: is_selected ? 2px : 1px;
    border-color: is_selected ? AppTheme.selection : AppTheme.border;

    touch := TouchArea {
        clicked => {
            root.node_clicked(root.node_id);
        }
        
        pointer-event(event) => {
            if (event.kind == PointerEventKind.down) {
                is-dragging = true;
                drag-start-pointer-x = (self.mouse-x / 1px) + root.x / 1px;
                drag-start-pointer-y = (self.mouse-y / 1px) + root.y / 1px;
                drag-start-node-x = root.x / 1px;
                drag-start-node-y = root.y / 1px;
            } else if (event.kind == PointerEventKind.up) {
                is-dragging = false;
                let pointer-x = (self.mouse-x / 1px) + root.x / 1px;
                let pointer-y = (self.mouse-y / 1px) + root.y / 1px;
                let new-x = drag-start-node-x + (pointer-x - drag-start-pointer-x);
                let new-y = drag-start-node-y + (pointer-y - drag-start-pointer-y);
                offset-x = new-x - root.x_pos;
                offset-y = new-y - root.y_pos;
                root.node_moved(root.x_pos + offset-x, root.y_pos + offset-y);
                root.node_move_finished(root.x_pos + offset-x, root.y_pos + offset-y);
            }
        }
        
        moved => {
            if (self.pressed && is-dragging) {
                let pointer-x = (self.mouse-x / 1px) + root.x / 1px;
                let pointer-y = (self.mouse-y / 1px) + root.y / 1px;
                let new-x = drag-start-node-x + (pointer-x - drag-start-pointer-x);
                let new-y = drag-start-node-y + (pointer-y - drag-start-pointer-y);
                offset-x = new-x - root.x_pos;
                offset-y = new-y - root.y_pos;
                root.node_moved(root.x_pos + offset-x, root.y_pos + offset-y);
            }
        }
    }

    CjkText {
        text: root.label;
        color: AppTheme.text-primary;
        horizontal-alignment: center;
        font-size: 14px;
        font-weight: 700;
        height: (grid_size * (root.preview_text == "" ? header_rows : 1)) * 1px;
        width: parent.width;
        x: 0px;
        y: 0px;
    }

    if root.preview_text != "": CjkText {
        text: root.preview_text;
        color: AppTheme.text-muted;
        horizontal-alignment: left;
        font-size: 11px;
        height: (grid_size) * 1px;
        width: parent.width - (grid_size) * 1px;
        x: (grid_size * 0.5) * 1px;
        y: (grid_size * 1.0) * 1px;
        wrap: word-wrap;
        overflow: elide;
    }

    for port[i] in input_ports: Rectangle {
        x: (grid_size * 0.2) * 1px;
        y: (grid_size * header_rows + i * grid_size + grid_size * 0.2) * 1px;
        width: (grid_size * 0.6) * 1px;
        height: (grid_size * 0.6) * 1px;
        border-radius: (grid_size * 0.3) * 1px;
        background: port.is_connected ? AppTheme.primary-muted : (port.is_required ? AppTheme.danger-bg : AppTheme.node-port-bg);
        border-width: 1px;
        border-color: port.is_connected ? AppTheme.primary : (port.is_required ? AppTheme.danger : AppTheme.node-port-border);

        TouchArea {
            pointer-event(event) => {
                if (event.kind == PointerEventKind.down) {
                    root.port_clicked(root.node_id, port.name, true);
                }
            }
        }
    }

    for port[i] in input_ports: Rectangle {
        x: (grid_size) * 1px;
        y: (grid_size * header_rows + i * grid_size) * 1px;
        width: root.width - (grid_size * 2.5) * 1px;
        height: (grid_size) * 1px;

        HorizontalLayout {
            alignment: start;
            spacing: 5px;

            CjkText {
                text: port.name;
                color: AppTheme.text-secondary;
                font-size: 10px;
                vertical-alignment: center;
                overflow: elide;
                horizontal-stretch: 0;
            }

            if (!port.is_connected && (port.data_type == "String" || port.data_type == "Integer" || port.data_type == "Float")): LineEdit {
                width: min(parent.width * 0.5, 120px);
                height: (grid_size * 0.8) * 1px;
                text: port.inline_text;
                placeholder-text: port.data_type;
                edited(text) => {
                    root.inline_port_text_changed(root.node_id, port.name, text);
                }
            }

            if (!port.is_connected && (port.data_type == "Boolean")): CheckBox {
                height: (grid_size * 0.7) * 1px;
                text: "";
                checked: port.inline_bool;
                toggled => {
                    root.inline_port_bool_changed(root.node_id, port.name, self.checked);
                }
            }
        }
    }

    // Special UI for string_data nodes: input field without port circle
    if root.node_type == "string_data": Rectangle {
        x: (grid_size) * 1px;
        y: (grid_size * header_rows) * 1px;
        width: root.width - (grid_size * 2.5) * 1px;
        height: (grid_size) * 1px;

        HorizontalLayout {
            alignment: start;
            spacing: 5px;

            CjkText {
                text: "text";
                color: AppTheme.text-secondary;
                font-size: 10px;
                vertical-alignment: center;
                overflow: elide;
                horizontal-stretch: 0;
            }

            LineEdit {
                width: min(parent.width * 0.6, 150px);
                height: (grid_size * 0.8) * 1px;
                text: root.string_data_text;
                placeholder-text: "输入字符串";
                edited(text) => {
                    root.inline_port_text_changed(root.node_id, "text", text);
                }
            }
        }
    }

    for port[i] in output_ports: Rectangle {
        x: root.width - (grid_size * 0.8) * 1px;
        y: (grid_size * header_rows + i * grid_size + grid_size * 0.2) * 1px;
        width: (grid_size * 0.6) * 1px;
        height: (grid_size * 0.6) * 1px;
        border-radius: (grid_size * 0.3) * 1px;
        background: port.is_connected ? AppTheme.primary-muted : (port.is_required ? AppTheme.danger-bg : AppTheme.node-port-bg);
        border-width: 1px;
        border-color: port.is_connected ? AppTheme.primary : (port.is_required ? AppTheme.danger : AppTheme.node-port-border);

        TouchArea {
            pointer-event(event) => {
                if (event.kind == PointerEventKind.down) {
                    root.port_clicked(root.node_id, port.name, false);
                }
            }
        }
    }

    for port[i] in output_ports: CjkText {
        text: port.name;
        color: AppTheme.text-secondary;
        font-size: 10px;
        vertical-alignment: center;
        horizontal-alignment: right;
        x: (grid_size) * 1px;
        y: (grid_size * header_rows + i * grid_size) * 1px;
        width: root.width - (grid_size * 2) * 1px;
        height: (grid_size) * 1px;
    }

    Rectangle {
        x: root.width - (grid_size * 0.6) * 1px;
        y: root.height - (grid_size * 0.5) * 1px - (grid_size * 0.1) * 1px;
        width: (grid_size * 0.5) * 1px;
        height: (grid_size * 0.5) * 1px;
        background: AppTheme.border;
        border-radius: 3px;

        TouchArea {
            pointer-event(event) => {
                if (event.kind == PointerEventKind.down) {
                    root.is-resizing = true;
                    root.resize-start-pointer-x = (self.mouse-x / 1px) + root.x / 1px;
                    root.resize-start-pointer-y = (self.mouse-y / 1px) + root.y / 1px;
                    root.resize-start-width = root.width / 1px;
                    root.resize-start-height = root.height / 1px;
                } else if (event.kind == PointerEventKind.up) {
                    root.is-resizing = false;
                    root.node_resize_finished(root.width / 1px, root.height / 1px);
                }
            }

            moved => {
                if (self.pressed && root.is-resizing) {
                    let pointer-x = (self.mouse-x / 1px) + root.x / 1px;
                    let pointer-y = (self.mouse-y / 1px) + root.y / 1px;
                    let new-width = root.resize-start-width + (pointer-x - root.resize-start-pointer-x);
                    let new-height = root.resize-start-height + (pointer-y - root.resize-start-pointer-y);
                    root.node_width = new-width;
                    root.node_height = new-height;
                    root.node_resized(root.node_width, root.node_height);
                }
            }
        }
    }
}

component GraphCanvas inherits Rectangle {
    in property <[NodeVm]> nodes;
    in property <[EdgeVm]> edges;
    in property <[EdgeSegmentVm]> edge_segments;
    in property <[EdgeCornerVm]> edge_corners;
    in property <[EdgeLabelVm]> edge_labels;
    in property <[GridLineVm]> grid_lines;
    in property <float> grid_size;
    in property <float> edge_thickness;
    in property <bool> drag_line_visible;
    in property <float> drag_line_from_x;
    in property <float> drag_line_from_y;
    in property <float> drag_line_to_x;
    in property <float> drag_line_to_y;
    in property <bool> box_selection_visible;
    in property <float> box_selection_x;
    in property <float> box_selection_y;
    in property <float> box_selection_width;
    in property <float> box_selection_height;
    
    callback node_moved(string, float, float);
    callback node_move_finished(string, float, float);
    callback port_clicked(string, string, bool);
    callback pointer_moved(float, float);
    callback cancel_connect();
    callback node_clicked(string);
    callback edge_clicked(string, string, string, string);
    callback canvas_clicked();
    callback box_selection_start(float, float);
    callback box_selection_update(float, float);
    callback box_selection_end();
    callback inline_port_text_changed(string, string, string);
    callback inline_port_bool_changed(string, string, bool);
    callback node_resized(string, float, float);
    callback node_resize_finished(string, float, float);

    in-out property <bool> dragging: false;
    in-out property <string> drag_from_node_id: "";
    in-out property <string> drag_from_port: "";
    in-out property <bool> drag_from_is_input: false;

    background: AppTheme.background;
    width: 100%;
    height: 100%;

    for line in grid_lines: Path {
        width: parent.width;
        height: parent.height;
        x: 0px;
        y: 0px;
        fill: transparent;
        stroke: AppTheme.grid-line;
        stroke-width: 1px;
        clip: false;
        viewbox-x: 0;
        viewbox-y: 0;
        viewbox-width: parent.width / 1px;
        viewbox-height: parent.height / 1px;

        MoveTo {
            x: line.x1;
            y: line.y1;
        }

        LineTo {
            x: line.x2;
            y: line.y2;
        }
    }

    drag_area := TouchArea {
        property <bool> is_box_selecting: false;
        
        clicked => {
            if !is_box_selecting {
                root.canvas_clicked();
            }
        }
        
        pointer-event(event) => {
            if (event.kind == PointerEventKind.down) {
                if (event.button == PointerEventButton.right) {
                    root.cancel_connect();
                } else if (event.button == PointerEventButton.left && event.modifiers.control) {
                    // Start box selection with Ctrl held
                    is_box_selecting = true;
                    root.box_selection_start(self.mouse-x / 1px, self.mouse-y / 1px);
                }
            } else if (event.kind == PointerEventKind.move) {
                if (is_box_selecting) {
                    root.box_selection_update(self.mouse-x / 1px, self.mouse-y / 1px);
                } else {
                    root.pointer_moved(self.mouse-x / 1px, self.mouse-y / 1px);
                }
            } else if (event.kind == PointerEventKind.up) {
                if (is_box_selecting) {
                    is_box_selecting = false;
                    root.box_selection_end();
                }
            }
        }

        moved => {
            if (is_box_selecting) {
                root.box_selection_update(self.mouse-x / 1px, self.mouse-y / 1px);
            } else {
                root.pointer_moved(self.mouse-x / 1px, self.mouse-y / 1px);
            }
        }
    }

    for segment[idx] in edge_segments: Rectangle {
        x: segment.x * 1px;
        y: segment.y * 1px;
        width: segment.width * 1px;
        height: segment.height * 1px;
        background: edges[segment.edge_index].is_selected ? AppTheme.edge-selected : AppTheme.edge;
        border-radius: (root.edge_thickness / 2) * 1px;
        
        TouchArea {
            clicked => {
                root.edge_clicked(
                    edges[segment.edge_index].from_node_id,
                    edges[segment.edge_index].from_port,
                    edges[segment.edge_index].to_node_id,
                    edges[segment.edge_index].to_port
                );
            }
        }
    }

    for corner[idx] in edge_corners: Rectangle {
        x: (corner.x - root.edge_thickness / 2) * 1px;
        y: (corner.y - root.edge_thickness / 2) * 1px;
        width: root.edge_thickness * 1px;
        height: root.edge_thickness * 1px;
        background: edges[corner.edge_index].is_selected ? AppTheme.edge-selected : AppTheme.edge;
        border-radius: (root.edge_thickness / 2) * 1px;
        
        TouchArea {
            clicked => {
                root.edge_clicked(
                    edges[corner.edge_index].from_node_id,
                    edges[corner.edge_index].from_port,
                    edges[corner.edge_index].to_node_id,
                    edges[corner.edge_index].to_port
                );
            }
        }
    }

    for label in edge_labels: Rectangle {
        x: (label.x - label.width / 2) * 1px;
        y: (label.y - label.height / 2) * 1px;
        width: label.width * 1px;
        height: label.height * 1px;
        background: AppTheme.label-bg;
        border-radius: 4px;
        border-width: 1px;
        border-color: AppTheme.label-border;

        CjkText {
            text: label.text;
            color: AppTheme.text-primary;
            horizontal-alignment: center;
            vertical-alignment: center;
            font-size: 10px;
        }
    }

    if root.drag_line_visible: Path {
        width: parent.width;
        height: parent.height;
        x: 0px;
        y: 0px;
        fill: transparent;
        stroke: AppTheme.edge;
        stroke-width: root.edge_thickness * 1px;
        viewbox-x: 0;
        viewbox-y: 0;
        viewbox-width: parent.width / 1px;
        viewbox-height: parent.height / 1px;

        MoveTo {
            x: root.drag_line_from_x;
            y: root.drag_line_from_y;
        }

        LineTo {
            x: (root.drag_line_from_x + root.drag_line_to_x) / 2;
            y: root.drag_line_from_y;
        }

        LineTo {
            x: (root.drag_line_from_x + root.drag_line_to_x) / 2;
            y: root.drag_line_to_y;
        }

        LineTo {
            x: root.drag_line_to_x;
            y: root.drag_line_to_y;
        }
    }
    
    // Box selection rectangle
    if root.box_selection_visible: Rectangle {
        x: root.box_selection_x * 1px;
        y: root.box_selection_y * 1px;
        width: root.box_selection_width * 1px;
        height: root.box_selection_height * 1px;
        background: AppTheme.selection-bg;
        border-width: 2px;
        border-color: AppTheme.selection;
        border-radius: 0px;
    }

    for node in nodes: NodeItem {
        node_id: node.id;
        label: node.label;
        preview_text: node.preview_text;
        node_type: node.node_type;
        string_data_text: node.string_data_text;
        x_pos: node.x;
        y_pos: node.y;
        node_width: node.width;
        node_height: node.height;
        input_ports: node.input_ports;
        output_ports: node.output_ports;
        grid_size: root.grid_size;
        node_width_cells: 10;
        header_rows: 2;
        min_rows: 3;
        is_selected: node.is_selected;
        
        node_moved(x, y) => {
            root.node_moved(node.id, x, y);
        }

        node_move_finished(x, y) => {
            root.node_move_finished(node.id, x, y);
        }
        
        port_clicked(node_id, port_name, is_input) => {
            root.port_clicked(node_id, port_name, is_input);
        }
        
        node_clicked(node_id) => {
            root.node_clicked(node_id);
        }

        inline_port_text_changed(node_id, port_name, value) => {
            root.inline_port_text_changed(node_id, port_name, value);
        }

        inline_port_bool_changed(node_id, port_name, value) => {
            root.inline_port_bool_changed(node_id, port_name, value);
        }

        node_resized(width, height) => {
            root.node_resized(node.id, width, height);
        }

        node_resize_finished(width, height) => {
            root.node_resize_finished(node.id, width, height);
        }
    }
}


export component ErrorDialog inherits Rectangle {
    in property <string> error_message;
    callback close();

    background: AppTheme.overlay-mask;

    TouchArea {
        clicked => { root.close(); }
    }

    Rectangle {
        x: (parent.width - self.width) / 2;
        y: (parent.height - self.height) / 2;
        width: 800px;
        height: 200px;
        background: AppTheme.error-bg;
        border-radius: 8px;
        border-width: 1px;
        border-color: AppTheme.error-border;

        TouchArea {} // Block clicks

        VerticalLayout {
            padding: 20px;
            spacing: 12px;

            // Top area: icon and content
            HorizontalLayout {
                spacing: 16px;

                // Error icon
                Rectangle {
                    width: 48px;
                    
                    VerticalLayout {
                        alignment: start;
                        
                        Rectangle {
                            width: 36px;
                            height: 36px;
                            border-radius: 18px;
                            background: AppTheme.error-icon-bg;

                            CjkText {
                                text: "!";
                                font-size: 24px;
                                color: AppTheme.text-on-primary;
                                horizontal-alignment: center;
                                vertical-alignment: center;
                                font-weight: 700;
                            }
                        }
                    }
                }

                // Content area
                VerticalLayout {
                    spacing: 8px;
                    
                    // Title
                    CjkText {
                        text: "节点图执行失败";
                        font-size: 16px;
                        color: AppTheme.error-title;
                        font-weight: 700;
                        horizontal-alignment: left;
                    }

                    // Error message with scrollbar
                    Rectangle {
                        background: AppTheme.error-message-bg;
                        border-radius: 4px;
                        border-width: 1px;
                        border-color: AppTheme.error-message-border;
                        
                        ScrollView {
                            VerticalLayout {
                                padding: 10px;
                                
                                CjkText {
                                    text: root.error_message;
                                    font-size: 12px;
                                    color: AppTheme.error-message-text;
                                    wrap: word-wrap;
                                    horizontal-alignment: left;
                                }
                            }
                        }
                    }
                }
            }

            // Bottom button area
            HorizontalBox {
                alignment: center;
                
                CjkButton {
                    text: "确定";
                    clicked => { root.close(); }
                }
            }
        }
    }
}

export component NodeSelector inherits Rectangle {
    in property <[NodeTypeVm]> node_types;
    in property <[string]> categories;
    callback add_node(string);
    callback close();
    callback filter(string, string);
    
    // Internal state for UI feedback
    property <string> current_search: "";
    property <string> current_category: "";

    background: AppTheme.overlay-mask;

    TouchArea {
        clicked => { root.close(); }
    }

    Rectangle {
        x: (parent.width - self.width) / 2;
        y: (parent.height - self.height) / 2;
        width: 700px;
        height: 600px;
        background: AppTheme.node-bg;
        border-radius: 12px;
        border-width: 2px;
        border-color: AppTheme.border;

        TouchArea {} // Block clicks

        VerticalBox {
            padding: 16px;
            spacing: 12px;

            CjkText {
                text: "选择节点类型";
                font-size: 18px;
                color: AppTheme.text-primary;
                horizontal-alignment: center;
                height: 30px;
            }
            
            // Search and Filter
            VerticalBox {
                spacing: 8px;
                
                HorizontalBox {
                    height: 50px;
                    CjkText {
                        text: "搜索:";
                        vertical-alignment: center;
                        width: 50px;
                        color: AppTheme.text-secondary;
                    }
                    LineEdit {
                         height: 35px;
                         placeholder-text: "输入节点名称...";
                         edited(text) => {
                             root.current_search = text;
                             root.filter(root.current_search, root.current_category);
                         }
                    }
                }
                
                HorizontalBox {
                   height: 50px;
                   CjkText {
                        text: "分类:";
                        vertical-alignment: center;
                        width: 50px;
                        color: AppTheme.text-secondary;
                   }
                   ScrollView {
                       viewport-height: 30px;
                       height: 40px; 
                       HorizontalLayout {
                           spacing: 8px;
                           padding-right: 8px;
                           alignment: start;
                           
                           // "All" button
                           Rectangle {
                               width: 60px;
                               height: 30px;
                               border-radius: 4px;
                               background: root.current_category == "" ? AppTheme.category-bg-selected : AppTheme.category-bg;
                               border-width: 1px;
                               border-color: AppTheme.border-light;
                               
                               TouchArea {
                                   clicked => {
                                        root.current_category = "";
                                        root.filter(root.current_search, root.current_category);
                                   }
                               }
                               
                               CjkText {
                                   text: "全部";
                                   color: root.current_category == "" ? AppTheme.category-text-selected : AppTheme.category-text;
                                   horizontal-alignment: center;
                                   vertical-alignment: center;
                                   font-size: 12px;
                               }
                           }

                           for category in root.categories : Rectangle {
                               width: 80px;
                               height: 30px;
                               border-radius: 4px;
                               background: root.current_category == category ? AppTheme.category-bg-selected : AppTheme.category-bg;
                               border-width: 1px;
                               border-color: AppTheme.border-light;
                               
                               TouchArea {
                                   clicked => {
                                        root.current_category = category;
                                        root.filter(root.current_search, root.current_category);
                                   }
                               }
                               
                               CjkText {
                                   text: category;
                                   color: root.current_category == category ? AppTheme.category-text-selected : AppTheme.category-text;
                                   horizontal-alignment: center;
                                   vertical-alignment: center;
                                   font-size: 12px;
                               }
                           }
                       }
                   }
                }
            }

            Rectangle {
                background: AppTheme.background;
                border-radius: 6px;
                border-color: AppTheme.border-light;
                border-width: 1px;
                
                ScrollView {
                    viewport-width: parent.width - 20px;
                    viewport-height: root.node_types.length * 100px; 

                    VerticalBox {
                        padding: 8px;
                        spacing: 8px;
                        alignment: start;

                        for node_type in root.node_types: Rectangle {
                            height: 80px;
                            background: AppTheme.surface-overlay;
                            border-radius: 6px;
                            border-width: 1px;
                            border-color: AppTheme.border;


                            TouchArea {
                                clicked => { 
                                    root.add_node(node_type.type_id);
                                    root.close();
                                }
                            }

                            VerticalLayout {
                                padding: 10px;
                                spacing: 6px;

                                HorizontalLayout {
                                    spacing: 8px;
                                    CjkText {
                                        text: node_type.display_name;
                                        font-size: 16px;
                                        color: AppTheme.text-primary;
                                        font-weight: 700;
                                        vertical-alignment: center;
                                    }

                                    Rectangle {
                                        background: AppTheme.category-bg;
                                        width: self.height * 2.5; 
                                        
                                        HorizontalLayout {
                                            padding-left: 6px;
                                            padding-right: 6px;
                                            CjkText {
                                                text: node_type.category;
                                                font-size: 11px;
                                                color: AppTheme.text-muted;
                                                vertical-alignment: center;
                                                horizontal-alignment: center;
                                            }
                                        }
                                    }
                                }

                                CjkText {
                                    text: node_type.description;
                                    font-size: 13px;
                                    color: AppTheme.text-muted;
                                    wrap: word-wrap;
                                    vertical-alignment: top;
                                    overflow: elide;
                                }
                            }
                        }
                    }
                }
            }

            HorizontalBox {
                alignment: center;
                CjkButton {
                    text: "取消";
                    clicked => { root.close(); }
                }
            }
        }
    }
}

export component NodeGraphWindow inherits Window {
    in property <[NodeVm]> nodes;
    in property <[EdgeVm]> edges;
    in property <[EdgeSegmentVm]> edge_segments;
    in property <[EdgeCornerVm]> edge_corners;
    in property <[EdgeLabelVm]> edge_labels;
    in property <[GridLineVm]> grid_lines;
    in property <float> grid_size: 20;
    in property <float> edge_thickness: 6;
    in property <string> connection_status: "";
    in property <string> current_file;
    in property <bool> show_node_selector: false;
    in property <[NodeTypeVm]> available_node_types;
    in property <[string]> node_categories;
    callback filter_nodes(string, string);
    in property <bool> drag_line_visible: false;
    in property <float> drag_line_from_x: 0;
    in property <float> drag_line_from_y: 0;
    in property <float> drag_line_to_x: 0;
    in property <float> drag_line_to_y: 0;
    in-out property <bool> dragging: false;
    in-out property <string> drag_from_node_id: "";
    in-out property <string> drag_from_port: "";
    in-out property <bool> drag_from_is_input: false;
    in property <int> selected_node_count: 0;
    in property <string> selected_edge_from_node: "";
    in property <string> selected_edge_from_port: "";
    in property <string> selected_edge_to_node: "";
    in property <string> selected_edge_to_port: "";
    in property <bool> box_selection_visible: false;
    in property <float> box_selection_x: 0;
    in property <float> box_selection_y: 0;
    in property <float> box_selection_width: 0;
    in property <float> box_selection_height: 0;
    in property <string> port_hint_text: "";
    in property <float> port_hint_x: 0;
    in property <float> port_hint_y: 0;
    in property <bool> show_port_hint: false;
    in property <bool> show_error_dialog: false;
    in property <string> error_dialog_message: "";

    callback open_json();
    callback save_json();
    callback add_node(string);
    callback run_graph();
    callback show_node_type_menu();
    callback hide_node_type_menu();
    callback show_error(string);
    callback hide_error();
    callback node_moved(string, float, float);
    callback node_move_finished(string, float, float);
    callback port_clicked(string, string, bool);
    callback pointer_moved(float, float);
    callback cancel_connect();
    callback node_clicked(string);
    callback edge_clicked(string, string, string, string);
    callback canvas_clicked();
    callback delete_selected();
    callback box_selection_start(float, float);
    callback box_selection_update(float, float);
    callback box_selection_end();
    callback inline_port_text_changed(string, string, string);
    callback inline_port_bool_changed(string, string, bool);
    callback node_resized(string, float, float);
    callback node_resize_finished(string, float, float);

    title: "Zihuan Node Graph Viewer";
    width: 1200px;
    height: 800px;

    VerticalBox {
        // Menu bar area
        Rectangle {
            height: 40px;
            background: AppTheme.surface;
            border-width: 1px;
            border-color: AppTheme.border;

            HorizontalBox {
                padding: 6px;
                spacing: 8px;
                alignment: start;

                CjkText {
                    text: "节点图";
                    color: AppTheme.text-primary;
                    font-size: 14px;
                    vertical-alignment: center;
                    width: 80px;
                }

                CjkButton {
                    text: "打开";
                    width: 80px;
                    height: 28px;
                    clicked => { root.open_json(); }
                }

                CjkButton {
                    text: "保存";
                    width: 80px;
                    height: 28px;
                    clicked => { root.save_json(); }
                }
            }
        }

        GraphCanvas {
            width: root.width;
            height: root.height - 120px;
            nodes: root.nodes;
            edges: root.edges;
            edge_segments: root.edge_segments;
            edge_corners: root.edge_corners;
            edge_labels: root.edge_labels;
            grid_lines: root.grid_lines;
            grid_size: root.grid_size;
            edge_thickness: root.edge_thickness;
            drag_line_visible: root.drag_line_visible;
            drag_line_from_x: root.drag_line_from_x;
            drag_line_from_y: root.drag_line_from_y;
            drag_line_to_x: root.drag_line_to_x;
            drag_line_to_y: root.drag_line_to_y;
            dragging: root.dragging;
            drag_from_node_id: root.drag_from_node_id;
            drag_from_port: root.drag_from_port;
            drag_from_is_input: root.drag_from_is_input;
            box_selection_visible: root.box_selection_visible;
            box_selection_x: root.box_selection_x;
            box_selection_y: root.box_selection_y;
            box_selection_width: root.box_selection_width;
            box_selection_height: root.box_selection_height;
            
            node_moved(node_id, x, y) => {
                root.node_moved(node_id, x, y);
            }

            node_move_finished(node_id, x, y) => {
                root.node_move_finished(node_id, x, y);
            }
            
            port_clicked(node_id, port_name, is_input) => {
                root.port_clicked(node_id, port_name, is_input);
            }
            pointer_moved(x, y) => {
                root.pointer_moved(x, y);
            }
            cancel_connect() => {
                root.cancel_connect();
            }
            
            node_clicked(node_id) => {
                root.node_clicked(node_id);
            }
            
            edge_clicked(from_node, from_port, to_node, to_port) => {
                root.edge_clicked(from_node, from_port, to_node, to_port);
            }
            
            canvas_clicked() => {
                root.canvas_clicked();
            }
            
            box_selection_start(x, y) => {
                root.box_selection_start(x, y);
            }
            
            box_selection_update(x, y) => {
                root.box_selection_update(x, y);
            }
            
            box_selection_end() => {
                root.box_selection_end();
            }

            inline_port_text_changed(node_id, port_name, value) => {
                root.inline_port_text_changed(node_id, port_name, value);
            }

            inline_port_bool_changed(node_id, port_name, value) => {
                root.inline_port_bool_changed(node_id, port_name, value);
            }

            node_resized(node_id, width, height) => {
                root.node_resized(node_id, width, height);
            }

            node_resize_finished(node_id, width, height) => {
                root.node_resize_finished(node_id, width, height);
            }
        }

        // Bottom control bar
        Rectangle {
            height: 60px;
            background: transparent;

            HorizontalBox {
                padding: 12px;
                padding-bottom: 12px;
                spacing: 12px;
                alignment: start;

                CjkButton {
                    text: "新增节点";
                    clicked => { root.show_node_type_menu(); }
                }
                
                CjkRunButton {
                    text: "运行节点图";
                    clicked => { root.run_graph(); }
                }
                
                if root.selected_node_count > 0 || root.selected_edge_from_node != "": CjkDeleteButton {
                    text: root.selected_node_count > 1 ? "删除选中节点" : "删除选中";
                    clicked => { root.delete_selected(); }
                }
            }

            // Port hint - centered at bottom with transparent background
            if root.show_port_hint: Rectangle {
                width: 300px;
                height: 30px;
                background: #00000060;
                border-radius: 4px;
                border-width: 1px;
                border-color: #4a4a4a;
                x: (parent.width - self.width) / 2;
                y: (parent.height - self.height) / 2;

                CjkText {
                    text: root.port_hint_text;
                    color: #ffffff;
                    horizontal-alignment: center;
                    vertical-alignment: center;
                    font-size: 12px;
                    width: 100%;
                    height: 100%;
                }
            }
        }
    }


    if root.show_node_selector: NodeSelector {
        node_types: root.available_node_types;
        categories: root.node_categories;
        close => { root.hide_node_type_menu(); }
        add_node(type_id) => { 
            root.add_node(type_id);
            root.hide_node_type_menu(); 
        }
        filter(text, category) => { root.filter_nodes(text, category); }
    }

    if root.show_error_dialog: ErrorDialog {
        error_message: root.error_dialog_message;
        close => { root.hide_error(); }
    }
}
