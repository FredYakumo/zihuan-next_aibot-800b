import { HorizontalBox, VerticalBox, ScrollView, LineEdit } from "std-widgets.slint";

export struct PortVm {
    name: string,
    is_input: bool,
    is_connected: bool,
    is_required: bool,
}

export struct NodeVm {
    id: string,
    label: string,
    x: float,
    y: float,
    input_ports: [PortVm],
    output_ports: [PortVm],
    is_selected: bool,
}

export struct EdgeVm {
    from_node_id: string,
    from_port: string,
    to_node_id: string,
    to_port: string,
    from_x: float,
    from_y: float,
    to_x: float,
    to_y: float,
    is_selected: bool,
}

export struct EdgeSegmentVm {
    x: float,
    y: float,
    width: float,
    height: float,
}

export struct EdgeCornerVm {
    x: float,
    y: float,
}

export struct EdgeLabelVm {
    text: string,
    x: float,
    y: float,
    width: float,
    height: float,
}

export struct GridLineVm {
    x1: float,
    y1: float,
    x2: float,
    y2: float,
}

export struct NodeTypeVm {
    type_id: string,
    display_name: string,
    category: string,
    description: string,
}

component CjkText inherits Text {
    font-family: "Heiti SC";
}

component CjkButton inherits Rectangle {
    in property <string> text;
    callback clicked();

    width: 120px;
    height: 32px;
    background: #2f2f2f;
    border-radius: 6px;
    border-width: 1px;
    border-color: #4a4a4a;

    TouchArea {
        clicked => { root.clicked(); }
    }

    CjkText {
        text: root.text;
        color: #f0f0f0;
        vertical-alignment: center;
        horizontal-alignment: center;
        font-size: 12px;
    }
}

component CjkDeleteButton inherits Rectangle {
    in property <string> text;
    callback clicked();

    width: 120px;
    height: 32px;
    background: #d32f2f;
    border-radius: 6px;
    border-width: 1px;
    border-color: #f44336;

    TouchArea {
        clicked => { root.clicked(); }
    }

    CjkText {
        text: root.text;
        color: #ffffff;
        vertical-alignment: center;
        horizontal-alignment: center;
        font-size: 12px;
        font-weight: 700;
    }
}

component NodeItem inherits Rectangle {
    in property <string> node_id;
    in property <string> label;
    in property <float> x_pos;
    in property <float> y_pos;
    in property <[PortVm]> input_ports;
    in property <[PortVm]> output_ports;
    in property <float> grid_size;
    in property <float> node_width_cells;
    in property <float> header_rows;
    in property <float> min_rows;
    in property <bool> is_selected;
    
    callback node_moved(float, float);
    callback node_move_finished(float, float);
    callback port_clicked(string, string, bool);
    callback node_clicked(string);

    property <float> offset-x: 0;
    property <float> offset-y: 0;
    property <float> drag-start-x: 0;
    property <float> drag-start-y: 0;
    property <bool> is-dragging: false;

    x: (x_pos + offset-x) * 1px;
    y: (y_pos + offset-y) * 1px;
    width: (grid_size * node_width_cells) * 1px;
    height: (grid_size * max(min_rows, header_rows + max(input_ports.length, output_ports.length))) * 1px;
    background: touch.pressed ? #3a3a3a : #2b2b2b;
    border-radius: 8px;
    border-width: is_selected ? 2px : 1px;
    border-color: is_selected ? #4caf50 : #4a4a4a;

    touch := TouchArea {
        clicked => {
            root.node_clicked(root.node_id);
        }
        
        pointer-event(event) => {
            if (event.kind == PointerEventKind.down) {
                is-dragging = true;
                drag-start-x = self.mouse-x / 1px;
                drag-start-y = self.mouse-y / 1px;
            } else if (event.kind == PointerEventKind.up) {
                is-dragging = false;
                offset-x = (self.mouse-x / 1px - drag-start-x);
                offset-y = (self.mouse-y / 1px - drag-start-y);
                root.node_moved(root.x_pos + offset-x, root.y_pos + offset-y);
                root.node_move_finished(root.x_pos + offset-x, root.y_pos + offset-y);
            }
        }
        
        moved => {
            if (self.pressed && is-dragging) {
                // Calculate offset and move node directly to follow mouse
                offset-x = (self.mouse-x / 1px - drag-start-x);
                offset-y = (self.mouse-y / 1px - drag-start-y);
                root.node_moved(root.x_pos + offset-x, root.y_pos + offset-y);
            }
        }
    }

    CjkText {
        text: root.label;
        color: #f0f0f0;
        horizontal-alignment: center;
        font-size: 14px;
        font-weight: 700;
        height: (grid_size * header_rows) * 1px;
        width: parent.width;
        x: 0px;
        y: 0px;
    }

    for port[i] in input_ports: Rectangle {
        x: (grid_size * 0.2) * 1px;
        y: (grid_size * header_rows + i * grid_size + grid_size * 0.2) * 1px;
        width: (grid_size * 0.6) * 1px;
        height: (grid_size * 0.6) * 1px;
        border-radius: (grid_size * 0.3) * 1px;
        background: port.is_connected ? #2d8659 : (port.is_required ? #d32f2f : #666666);
        border-width: 1px;
        border-color: port.is_connected ? #4caf50 : (port.is_required ? #f44336 : #999999);

        TouchArea {
            pointer-event(event) => {
                if (event.kind == PointerEventKind.down) {
                    root.port_clicked(root.node_id, port.name, true);
                }
            }
        }
    }

    for port[i] in input_ports: CjkText {
        text: port.name;
        color: #cccccc;
        font-size: 10px;
        vertical-alignment: center;
        x: (grid_size) * 1px;
        y: (grid_size * header_rows + i * grid_size) * 1px;
        width: (grid_size * (node_width_cells - 2)) * 1px;
        height: (grid_size) * 1px;
    }

    for port[i] in output_ports: Rectangle {
        x: (grid_size * (node_width_cells - 1) + grid_size * 0.2) * 1px;
        y: (grid_size * header_rows + i * grid_size + grid_size * 0.2) * 1px;
        width: (grid_size * 0.6) * 1px;
        height: (grid_size * 0.6) * 1px;
        border-radius: (grid_size * 0.3) * 1px;
        background: port.is_connected ? #7a5a1f : #666666;
        border-width: 1px;
        border-color: port.is_connected ? #b58a3b : #999999;

        TouchArea {
            pointer-event(event) => {
                if (event.kind == PointerEventKind.down) {
                    root.port_clicked(root.node_id, port.name, false);
                }
            }
        }
    }

    for port[i] in output_ports: CjkText {
        text: port.name;
        color: #cccccc;
        font-size: 10px;
        vertical-alignment: center;
        horizontal-alignment: right;
        x: (grid_size) * 1px;
        y: (grid_size * header_rows + i * grid_size) * 1px;
        width: (grid_size * (node_width_cells - 2)) * 1px;
        height: (grid_size) * 1px;
    }
}

component GraphCanvas inherits Rectangle {
    in property <[NodeVm]> nodes;
    in property <[EdgeVm]> edges;
    in property <[EdgeSegmentVm]> edge_segments;
    in property <[EdgeCornerVm]> edge_corners;
    in property <[EdgeLabelVm]> edge_labels;
    in property <[GridLineVm]> grid_lines;
    in property <float> grid_size;
    in property <float> edge_thickness;
    in property <bool> drag_line_visible;
    in property <float> drag_line_from_x;
    in property <float> drag_line_from_y;
    in property <float> drag_line_to_x;
    in property <float> drag_line_to_y;
    in property <bool> box_selection_visible;
    in property <float> box_selection_x;
    in property <float> box_selection_y;
    in property <float> box_selection_width;
    in property <float> box_selection_height;
    
    callback node_moved(string, float, float);
    callback node_move_finished(string, float, float);
    callback port_clicked(string, string, bool);
    callback pointer_moved(float, float);
    callback cancel_connect();
    callback node_clicked(string);
    callback edge_clicked(string, string, string, string);
    callback canvas_clicked();
    callback box_selection_start(float, float);
    callback box_selection_update(float, float);
    callback box_selection_end();

    in-out property <bool> dragging: false;
    in-out property <string> drag_from_node_id: "";
    in-out property <string> drag_from_port: "";
    in-out property <bool> drag_from_is_input: false;

    background: #1e1e1e;

    for line in grid_lines: Path {
        width: parent.width;
        height: parent.height;
        x: 0px;
        y: 0px;
        fill: transparent;
        stroke: #2a2a2a;
        stroke-width: 1px;
        clip: false;
        viewbox-x: 0;
        viewbox-y: 0;
        viewbox-width: parent.width / 1px;
        viewbox-height: parent.height / 1px;

        MoveTo {
            x: line.x1;
            y: line.y1;
        }

        LineTo {
            x: line.x2;
            y: line.y2;
        }
    }

    drag_area := TouchArea {
        property <bool> is_box_selecting: false;
        
        clicked => {
            if !is_box_selecting {
                root.canvas_clicked();
            }
        }
        
        pointer-event(event) => {
            if (event.kind == PointerEventKind.down) {
                if (event.button == PointerEventButton.right) {
                    root.cancel_connect();
                } else if (event.button == PointerEventButton.left && event.modifiers.control) {
                    // Start box selection with Ctrl held
                    is_box_selecting = true;
                    root.box_selection_start(self.mouse-x / 1px, self.mouse-y / 1px);
                }
            } else if (event.kind == PointerEventKind.up) {
                if (is_box_selecting) {
                    is_box_selecting = false;
                    root.box_selection_end();
                }
            }
        }

        moved => {
            if (is_box_selecting) {
                root.box_selection_update(self.mouse-x / 1px, self.mouse-y / 1px);
            } else {
                root.pointer_moved(self.mouse-x / 1px, self.mouse-y / 1px);
            }
        }
    }

    for segment[idx] in edge_segments: Rectangle {
        x: segment.x * 1px;
        y: segment.y * 1px;
        width: segment.width * 1px;
        height: segment.height * 1px;
        background: edges[idx].is_selected ? #4caf50 : #ffffff;
        border-radius: (root.edge_thickness / 2) * 1px;
        
        TouchArea {
            clicked => {
                root.edge_clicked(
                    edges[idx].from_node_id,
                    edges[idx].from_port,
                    edges[idx].to_node_id,
                    edges[idx].to_port
                );
            }
        }
    }

    for corner[idx] in edge_corners: Rectangle {
        x: (corner.x - root.edge_thickness / 2) * 1px;
        y: (corner.y - root.edge_thickness / 2) * 1px;
        width: root.edge_thickness * 1px;
        height: root.edge_thickness * 1px;
        background: edges[idx].is_selected ? #4caf50 : #ffffff;
        border-radius: (root.edge_thickness / 2) * 1px;
        
        TouchArea {
            clicked => {
                root.edge_clicked(
                    edges[idx].from_node_id,
                    edges[idx].from_port,
                    edges[idx].to_node_id,
                    edges[idx].to_port
                );
            }
        }
    }

    for label in edge_labels: Rectangle {
        x: (label.x - label.width / 2) * 1px;
        y: (label.y - label.height / 2) * 1px;
        width: label.width * 1px;
        height: label.height * 1px;
        background: #1e1e1ecc;
        border-radius: 4px;
        border-width: 1px;
        border-color: #444444;

        CjkText {
            text: label.text;
            color: #ffffff;
            horizontal-alignment: center;
            vertical-alignment: center;
            font-size: 10px;
        }
    }

    if root.drag_line_visible: Path {
        width: parent.width;
        height: parent.height;
        x: 0px;
        y: 0px;
        fill: transparent;
        stroke: #ffffff;
        stroke-width: root.edge_thickness * 1px;
        viewbox-x: 0;
        viewbox-y: 0;
        viewbox-width: parent.width / 1px;
        viewbox-height: parent.height / 1px;

        MoveTo {
            x: root.drag_line_from_x;
            y: root.drag_line_from_y;
        }

        LineTo {
            x: (root.drag_line_from_x + root.drag_line_to_x) / 2;
            y: root.drag_line_from_y;
        }

        LineTo {
            x: (root.drag_line_from_x + root.drag_line_to_x) / 2;
            y: root.drag_line_to_y;
        }

        LineTo {
            x: root.drag_line_to_x;
            y: root.drag_line_to_y;
        }
    }
    
    // Box selection rectangle
    if root.box_selection_visible: Rectangle {
        x: root.box_selection_x * 1px;
        y: root.box_selection_y * 1px;
        width: root.box_selection_width * 1px;
        height: root.box_selection_height * 1px;
        background: #4caf5030;
        border-width: 2px;
        border-color: #4caf50;
        border-radius: 0px;
    }

    for node in nodes: NodeItem {
        node_id: node.id;
        label: node.label;
        x_pos: node.x;
        y_pos: node.y;
        input_ports: node.input_ports;
        output_ports: node.output_ports;
        grid_size: root.grid_size;
        node_width_cells: 8;
        header_rows: 2;
        min_rows: 3;
        is_selected: node.is_selected;
        
        node_moved(x, y) => {
            root.node_moved(node.id, x, y);
        }

        node_move_finished(x, y) => {
            root.node_move_finished(node.id, x, y);
        }
        
        port_clicked(node_id, port_name, is_input) => {
            root.port_clicked(node_id, port_name, is_input);
        }
        
        node_clicked(node_id) => {
            root.node_clicked(node_id);
        }
    }
}


export component NodeSelector inherits Rectangle {
    in property <[NodeTypeVm]> node_types;
    in property <[string]> categories;
    callback add_node(string);
    callback close();
    callback filter(string, string);
    
    // Internal state for UI feedback
    property <string> current_search: "";
    property <string> current_category: "";

    background: #00000080;

    TouchArea {
        clicked => { root.close(); }
    }

    Rectangle {
        x: (parent.width - self.width) / 2;
        y: (parent.height - self.height) / 2;
        width: 700px;
        height: 600px;
        background: #2b2b2b;
        border-radius: 12px;
        border-width: 2px;
        border-color: #4a4a4a;

        TouchArea {} // Block clicks

        VerticalBox {
            padding: 16px;
            spacing: 12px;

            CjkText {
                text: "选择节点类型";
                font-size: 18px;
                color: #f0f0f0;
                horizontal-alignment: center;
                height: 30px;
            }
            
            // Search and Filter
            VerticalBox {
                spacing: 8px;
                
                HorizontalBox {
                    height: 35px;
                    CjkText {
                        text: "搜索:";
                        vertical-alignment: center;
                        width: 40px;
                        color: #cccccc;
                    }
                    LineEdit {
                         placeholder-text: "输入节点名称...";
                         edited(text) => {
                             root.current_search = text;
                             root.filter(root.current_search, root.current_category);
                         }
                    }
                }
                
                HorizontalBox {
                   height: 40px;
                   CjkText {
                        text: "分类:";
                        vertical-alignment: center;
                        width: 40px;
                        color: #cccccc;
                   }
                   ScrollView {
                       HorizontalLayout {
                           spacing: 8px;
                           padding-right: 8px;
                           alignment: start;
                           
                           // "All" button
                           Rectangle {
                               width: 60px;
                               height: 30px;
                               border-radius: 4px;
                               background: root.current_category == "" ? #4caf50 : #3a3a3a;
                               border-width: 1px;
                               border-color: #555555;
                               
                               TouchArea {
                                   clicked => {
                                        root.current_category = "";
                                        root.filter(root.current_search, root.current_category);
                                   }
                               }
                               
                               CjkText {
                                   text: "全部";
                                   color: #ffffff;
                                   horizontal-alignment: center;
                                   vertical-alignment: center;
                                   font-size: 12px;
                               }
                           }

                           for category in root.categories : Rectangle {
                               width: 80px;
                               height: 30px;
                               border-radius: 4px;
                               background: root.current_category == category ? #4caf50 : #3a3a3a;
                               border-width: 1px;
                               border-color: #555555;
                               
                               TouchArea {
                                   clicked => {
                                        root.current_category = category;
                                        root.filter(root.current_search, root.current_category);
                                   }
                               }
                               
                               CjkText {
                                   text: category;
                                   color: #ffffff;
                                   horizontal-alignment: center;
                                   vertical-alignment: center;
                                   font-size: 12px;
                               }
                           }
                       }
                   }
                }
            }

            Rectangle {
                background: #1e1e1e;
                border-radius: 6px;
                border-color: #333333;
                border-width: 1px;
                
                ScrollView {
                    viewport-width: parent.width;
                    viewport-height: root.node_types.length * 85px; 

                    VerticalBox {
                        padding: 8px;
                        spacing: 8px;
                        alignment: start;

                        for node_type in root.node_types: Rectangle {
                            height: 80px;
                            background: #2f2f2f;
                            border-radius: 6px;
                            border-width: 1px;
                            border-color: #4a4a4a;

                            TouchArea {
                                clicked => { 
                                    root.add_node(node_type.type_id);
                                    root.close();
                                }
                            }

                            VerticalLayout {
                                padding: 10px;
                                spacing: 6px;

                                HorizontalLayout {
                                    spacing: 8px;
                                    CjkText {
                                        text: node_type.display_name;
                                        font-size: 16px;
                                        color: #ffffff;
                                        font-weight: 700;
                                        vertical-alignment: center;
                                    }

                                    Rectangle {
                                        background: #3a3a3a;
                                        border-radius: 4px;
                                        width: self.height * 2.5; 
                                        
                                        HorizontalLayout {
                                            padding-left: 6px;
                                            padding-right: 6px;
                                            CjkText {
                                                text: node_type.category;
                                                font-size: 11px;
                                                color: #aaaaaa;
                                                vertical-alignment: center;
                                                horizontal-alignment: center;
                                            }
                                        }
                                    }
                                }

                                CjkText {
                                    text: node_type.description;
                                    font-size: 13px;
                                    color: #bbbbbb;
                                    wrap: word-wrap;
                                    vertical-alignment: top;
                                    overflow: elide;
                                }
                            }
                        }
                    }
                }
            }

            HorizontalBox {
                alignment: center;
                CjkButton {
                    text: "取消";
                    clicked => { root.close(); }
                }
            }
        }
    }
}

export component NodeGraphWindow inherits Window {
    in property <[NodeVm]> nodes;
    in property <[EdgeVm]> edges;
    in property <[EdgeSegmentVm]> edge_segments;
    in property <[EdgeCornerVm]> edge_corners;
    in property <[EdgeLabelVm]> edge_labels;
    in property <[GridLineVm]> grid_lines;
    in property <float> grid_size: 20;
    in property <float> edge_thickness: 6;
    in property <string> connection_status: "";
    in property <string> current_file;
    in property <bool> show_node_selector: false;
    in property <[NodeTypeVm]> available_node_types;
    in property <[string]> node_categories;
    callback filter_nodes(string, string);
    in property <bool> drag_line_visible: false;
    in property <float> drag_line_from_x: 0;
    in property <float> drag_line_from_y: 0;
    in property <float> drag_line_to_x: 0;
    in property <float> drag_line_to_y: 0;
    in-out property <bool> dragging: false;
    in-out property <string> drag_from_node_id: "";
    in-out property <string> drag_from_port: "";
    in-out property <bool> drag_from_is_input: false;
    in property <int> selected_node_count: 0;
    in property <string> selected_edge_from_node: "";
    in property <string> selected_edge_from_port: "";
    in property <string> selected_edge_to_node: "";
    in property <string> selected_edge_to_port: "";
    in property <bool> box_selection_visible: false;
    in property <float> box_selection_x: 0;
    in property <float> box_selection_y: 0;
    in property <float> box_selection_width: 0;
    in property <float> box_selection_height: 0;

    callback open_json();
    callback save_json();
    callback add_node(string);
    callback show_node_type_menu();
    callback hide_node_type_menu();
    callback node_moved(string, float, float);
    callback node_move_finished(string, float, float);
    callback port_clicked(string, string, bool);
    callback pointer_moved(float, float);
    callback cancel_connect();
    callback node_clicked(string);
    callback edge_clicked(string, string, string, string);
    callback canvas_clicked();
    callback delete_selected();
    callback box_selection_start(float, float);
    callback box_selection_update(float, float);
    callback box_selection_end();

    title: "Zihuan Node Graph Viewer";
    width: 1200px;
    height: 800px;

    HorizontalBox {
        spacing: 12px;
        padding: 12px;

        GraphCanvas {
            width: 860px;
            height: 760px;
            nodes: root.nodes;
            edges: root.edges;
            edge_segments: root.edge_segments;
            edge_corners: root.edge_corners;
            edge_labels: root.edge_labels;
            grid_lines: root.grid_lines;
            grid_size: root.grid_size;
            edge_thickness: root.edge_thickness;
            drag_line_visible: root.drag_line_visible;
            drag_line_from_x: root.drag_line_from_x;
            drag_line_from_y: root.drag_line_from_y;
            drag_line_to_x: root.drag_line_to_x;
            drag_line_to_y: root.drag_line_to_y;
            dragging: root.dragging;
            drag_from_node_id: root.drag_from_node_id;
            drag_from_port: root.drag_from_port;
            drag_from_is_input: root.drag_from_is_input;
            box_selection_visible: root.box_selection_visible;
            box_selection_x: root.box_selection_x;
            box_selection_y: root.box_selection_y;
            box_selection_width: root.box_selection_width;
            box_selection_height: root.box_selection_height;
            
            node_moved(node_id, x, y) => {
                root.node_moved(node_id, x, y);
            }

            node_move_finished(node_id, x, y) => {
                root.node_move_finished(node_id, x, y);
            }
            
            port_clicked(node_id, port_name, is_input) => {
                root.port_clicked(node_id, port_name, is_input);
            }
            pointer_moved(x, y) => {
                root.pointer_moved(x, y);
            }
            cancel_connect() => {
                root.cancel_connect();
            }
            
            node_clicked(node_id) => {
                root.node_clicked(node_id);
            }
            
            edge_clicked(from_node, from_port, to_node, to_port) => {
                root.edge_clicked(from_node, from_port, to_node, to_port);
            }
            
            canvas_clicked() => {
                root.canvas_clicked();
            }
            
            box_selection_start(x, y) => {
                root.box_selection_start(x, y);
            }
            
            box_selection_update(x, y) => {
                root.box_selection_update(x, y);
            }
            
            box_selection_end() => {
                root.box_selection_end();
            }
        }

        VerticalBox {
            width: 300px;
            height: 760px;
            spacing: 8px;

            CjkButton {
                text: "读取节点图文件";
                clicked => { root.open_json(); }
            }

            CjkButton {
                text: "保存节点图文件";
                clicked => { root.save_json(); }
            }

            CjkButton {
                text: "新增节点";
                clicked => { root.show_node_type_menu(); }
            }
            
            if root.selected_node_count > 0 || root.selected_edge_from_node != "": CjkDeleteButton {
                text: root.selected_node_count > 1 ? "删除选中节点" : "删除选中";
                clicked => { root.delete_selected(); }
            }

            CjkText {
                text: root.current_file;
                font-size: 12px;
                color: #555555;
                wrap: word-wrap;
            }

            CjkText {
                text: root.connection_status;
                font-size: 12px;
                color: #8ab4f8;
                wrap: word-wrap;
            }

            CjkText {
                text: "Edges";
                font-size: 16px;
                color: #f0f0f0;
            }

            Rectangle {
                background: #2b2b2b;
                border-radius: 4px;
                height: 200px;
                
                ScrollView {
                    VerticalBox {
                        padding: 4px;
                        spacing: 2px;
                        
                        for edge in edges: CjkText {
                            text: edge.from_node_id + ":" + edge.from_port + " → " + edge.to_node_id + ":" + edge.to_port;
                            font-size: 10px;
                            color: #aaaaaa;
                        }
                    }
                }
            }
        }
    }

    if root.show_node_selector: NodeSelector {
        node_types: root.available_node_types;
        categories: root.node_categories;
        close => { root.hide_node_type_menu(); }
        add_node(type_id) => { 
            root.add_node(type_id);
            root.hide_node_type_menu(); 
        }
        filter(text, category) => { root.filter_nodes(text, category); }
    }
}
